
TODOS:
** IN PRIORITY ORDER, WITH COMPLETED AT THE BOTTOM ***

Handling POST of complex content types, storing to S3:
- Implement a database backend on DynamoDB, with indexes to get students by name
    - Look into Java: DynamoDBMapper
    - Make sure to do interfaces and unit tests
    - Hook into existing StudentManager classes
    - Add something to the front page to list the first couple students and allow you to search for students.
- Accept a student picture as part of the students POST endpoint, upload it to blob store (synchronously), and return
the URL in GET.  May require implementing Multipart MIME
- Figure out how to make the servlet respond to the request asynchronously (with a thread pool?) so we don't tie up a
response thread from the serving container (eg Tomcat)
- Figure out how to make the S3 code asynchronous with a thread pool.
- More JMeter load tests to stress this.

SQL Database
- Make the students data a MySQL or similar table.

Using SQS for batch processing of messages:
- Use /rosters endpoint to post a OneRoster standard CSV that populates the /students endpoint
- Develop a separate processor that reads from the queue and adds students using the /students endpoint
- Might involve throwing data in a database somewhere to keep memory from blowing up.

Logging and other Metrics?
Adding an external Cache?

- DONE Swagger docs?

Basic AutoScaling App:
- DONE Figure out why index.jsp is not serving up
- DONE Switch to integrated Gradle build
- DONE Switch to RestEasy with Guice DI
- DONE Get Unit Tests Working and running for basic app.
- DONE Add dependency injection via Guice rather than the Jersey injectors
- DONE Get /students endpoint POST and GET working with POJOs and simple in-memory storage.
- DONE Add logging
- DONE Simulate an increased workload per request with some kind of busywork, that can be switched with a query param.
- DONE Develop a JMeter test to stress the /students endpoint
- DONE Deploy this to EC2 with a Tomcat container
- DONE Deploy JMeter tests to EC2 to stress app instances there
- DONE Try to deploy autoscaling groups based on a coarse measure, like CPU usage.
- DONE Create a BlobStore service implemented with S3 that uploads a local file.  Add unit\integration tests.
- DONE Figure out how to handle config for this - eg a properties file and local environment variables
- DONE Add a simple HTML front end using a template engine like Freemarker.  That will make it easier to see data in
 the app and post changes.


New questions:
- What is the call chaining in java called?  Eg used w\ builders
- How do you return a list of data in a DI friendly way?  Using new feels a little dirty...
- Explain the limitations of DynamoDB, particularly around primary keys and secondary indexes.
- How to do pagination?
- How to convert POJOs to JSON, etc for storage and re-hydration in the DB?
- Is there a simple way to map collections of one type to another?  For example, Dynamo's ItemCollection to a regular
List<mytype>?
- How to deal with database exceptions in the DAO?
- Discuss secondary indexes in DynamoDB, and how I would design them for my Students table.  I think I need separate
global secondary indexes for Student ID, and name.  Each of these is not guaranteed to be unique, but doesn't have to
be because the primary key is pulled in with it by default.  How do I deal with eventual consistency issues here?
I guess as long as we are working with or updating a student we will always have its primary key.  Only when we are
searching will eventual consistency matter which should be fine for our query pattern.  Pattern is search by ID \
name - get primary key, look up\modify student based on the primary.  We could potentially add a range key for district,
 school, entitlement, etc to reduce the number of records needed to scan for queries.  District would be the primary,
 name would be range (for example).  This way we could deal with eventual consistency, because we could always guarantee
 strong consistency for each district's data for new name \ ID searches when students are added.

Answered Questions:
- How to organize typesafe configs in code?  How to deal with multiple config files, and have the correct one selected
when using DI?
A: Typesafe is designed to work with a single large Config file that you pass around.  This should be fine for my
purposes.
- Re: @Provides: Wow.  How does it track which method to use, the return value?  That is, the S3 client method could be
@Provides AmazonS3Client getSomeObject()
A: Say if you have more than one method returning the same instance type, then Guice will throw errors saying an object
of same instance type is already bound.  But if you have a need to say return more than one instance of same instance
type then you will have to use @Named and bind based on the name.
- Review how my library is organized.  How do we separate setup code like config and module vs actual implementation?
What about API vs actual implementation.  I kept them in the same package under different namespaces for convenience,
if I was doing this *for real* I would separate implementation into a different lib and wire in using Guice?
A: The idea with keeping API models \ interfaces seperate is that they can be inherited \ extended by your clients.
For example, if a client needs a POJO model object to do something slightly different or additional.
You always want to keep config and DI code with the consumers of the library, not the library itself.  The lib should
not know where its config comes from, or how its objects are created, that is a client concern.
- What is the best way to model SQL data in java objects?  I am implementing a table of student info.  I'm thinking of
using a DAO pattern.  I have a student POJO object already.  Implement an interface for how to get \ set students,
StudentDAOImpl would actually implement this interface with MySQL or similar.  What are advantages of Repo pattern over
this?  Could use hibernate too, I would think this is only appropriate with simpler objects since I've heard it can
be tricky to understand\optimize what is happening with queries.
A: DAO is better for simpler data objects, and easy to get started with.  The disadvantage is that the db implementation
classes are always custom to the application and need to be purpose built.  The repo pattern abstracts the data into a
map of maps that is flexbile enough to accomodate almost any data schema.  If you decided to switch to another database
completely (even SQL->NoSQL) all you would have to do is implement the base repo "driver" interfaces to implement your
model.  In other words, the base repo object and db implementations can be shared between projects and have minimal
coupling to the application that implements them.
Bottom line: it is fine to go with DAO to start.
- Why builder pattern?  Advantages \ disadvantages.  Another name for Factory pattern?
A: Makes it easier to enforce creation rules for objects, particularly when you have lengthy constructors where a base
set of members need to be defined.  Look at how Lobok does Builders.  Also, you can chain together multiple calls.
- How to get autocomplete fixed up in IntelliJ?
A: Refresh Gradle configs in IntelliJ... :D
- Explain gradle testCompile vs compile?  Compile is the group of dependencies you need for your app while testCompile
are the dependencies only needed for test.  If you testCompile, the dependencies won't be available for the main app.
- What is appropriate to store in a properties or config file?  Basically anything you'd want to be configurable, like
names of your buckets, queues, regions, etc.  Timeouts.  That sort of thing.
- What's with Web.xml and the Servlet 3.x spec?  Many of the tutorials configure this through code, but
in CS we still seem to use Web.xml.  Why?  Force of habit, and some inconsistencies between Tomcat, Jetty.
In other words Web.xml is more compatible and consistent between containers.
- When is appropriate to inject dependencies? Generally use DI whenever you use "new" and only create POJOs on the
stack.  DI automatically defers loading of dependencies to optimize startup.  Eg, Loads class files, but not objects
until they are needed.
- Explain how we wire up dependency injection via in CS (so I can mirror).  Use Servlet Context Listeners, which
are the primary hook for when your app loads up - getModules is where the magic is for Guice.  Modules are def'ns
for what beans get wired to which other beans, with a namespace.
- Probably this will also involve standing up some configuration code, especially when I start
introducing dependencies like S3 and SQS
- Explain rules of thumb for code organization - generally across seams in your app - eg controllers (external
endpoint def'n and communication), services which are business logic to do stuff, a Repo tier.
- Good basic MVP project for all of this stuff is here:
https://github.com/patrickianwilson/blog-testing-demonstration
- Explain @Provides vs regular @Inject.  This implements the provider\factory pattern and is used when creating an
 object is very complex or not possible with the usual DI framework.  Allows you to create an instance (eg with new)
 or select an instance and return it to the framework.  @Inject is the opposite, it tells the framework to create your
 object and inject all of the dependencies it needs.
objects you create with new to be added into the DI chain?  Why not just use a regular class?
- What are advantages\disadvantages of concurrency model for Java vs other technologies like node.js?  Node.js and
event-based programming makes everything asynchronous, which is actually pretty good in many cases since this improves
utilization of a single process, allowing you to get the most out of it.  Complexity in spreading this across many cores
though, you need to add a broker in front of it.  The JVM is highly optimized, and exposes lower level methods to
leverage lighter weight mechanisms like threads to implement concurrency.  It is a little more efficient at the cost of
a lot of complexity.  Using this method, the container (eg Tomcat) can scale across multiple cores in a system.  It also
offers more advanced features like connection throttling that prevent the server from being bottlenecked on a single
task as can happen with Node.js.
- What's the best way to make a Java Servlet asynchronous?  There are typically only a limited number of request threads
and these need to be treated like gold.  Ideally you only want these accepting and responding to requests, and not doing
any grunt work.  Offloading the grunt work can be done with a request queue, put a job on the queue and have another
process grab it.  Another way to do this is by making the servlet handler respond asynchronously.  That way, you can
have bocking code in dependent services that is handled by a thread pool without tying up your main request threads.
- How do you integration test a component that uses a DI framework to inject its dependencies?  Especially when
you want to use the real objects (eg a database connection), and not mocks.  Can use the JUnit framework, and create\
inject the dependencies by hand with new.  You can bootstrap the DI framework, but this is generally overkill and adds
too much overhead\complexity.  If you are really dealing with isolated classes, using new should be simpler.  Adding in
DI is usually only appropriate for large, system-level integration tests.